// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file pet.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "pet.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


#define benchmark_idl_Owner_max_cdr_typesize 264ULL;
#define benchmark_idl_OwnerV2_max_cdr_typesize 264ULL;
#define benchmark_idl_OwnerV3_max_cdr_typesize 264ULL;
#define benchmark_idl_Pet_max_cdr_typesize 13717124ULL;
#define benchmark_idl_OwnerV4_max_cdr_typesize 264ULL;

#define benchmark_idl_Owner_max_key_cdr_typesize 0ULL;
#define benchmark_idl_OwnerV2_max_key_cdr_typesize 0ULL;
#define benchmark_idl_OwnerV3_max_key_cdr_typesize 0ULL;
#define benchmark_idl_Pet_max_key_cdr_typesize 0ULL;
#define benchmark_idl_OwnerV4_max_key_cdr_typesize 0ULL;


benchmark::idl::Owner::Owner()
{
    // string m_name
    m_name ="";
    // long m_age
    m_age = 0;

}

benchmark::idl::Owner::~Owner()
{


}

benchmark::idl::Owner::Owner(
        const Owner& x)
{
    m_name = x.m_name;
    m_age = x.m_age;
}

benchmark::idl::Owner::Owner(
        Owner&& x) noexcept 
{
    m_name = std::move(x.m_name);
    m_age = x.m_age;
}

benchmark::idl::Owner& benchmark::idl::Owner::operator =(
        const Owner& x)
{

    m_name = x.m_name;
    m_age = x.m_age;

    return *this;
}

benchmark::idl::Owner& benchmark::idl::Owner::operator =(
        Owner&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_age = x.m_age;

    return *this;
}

bool benchmark::idl::Owner::operator ==(
        const Owner& x) const
{

    return (m_name == x.m_name && m_age == x.m_age);
}

bool benchmark::idl::Owner::operator !=(
        const Owner& x) const
{
    return !(*this == x);
}

size_t benchmark::idl::Owner::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_Owner_max_cdr_typesize;
}

size_t benchmark::idl::Owner::getCdrSerializedSize(
        const benchmark::idl::Owner& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void benchmark::idl::Owner::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name.c_str();
    scdr << m_age;

}

void benchmark::idl::Owner::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_age;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void benchmark::idl::Owner::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void benchmark::idl::Owner::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& benchmark::idl::Owner::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& benchmark::idl::Owner::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member age
 * @param _age New value for member age
 */
void benchmark::idl::Owner::age(
        int32_t _age)
{
    m_age = _age;
}

/*!
 * @brief This function returns the value of member age
 * @return Value of member age
 */
int32_t benchmark::idl::Owner::age() const
{
    return m_age;
}

/*!
 * @brief This function returns a reference to member age
 * @return Reference to member age
 */
int32_t& benchmark::idl::Owner::age()
{
    return m_age;
}



size_t benchmark::idl::Owner::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_Owner_max_key_cdr_typesize;
}

bool benchmark::idl::Owner::isKeyDefined()
{
    return false;
}

void benchmark::idl::Owner::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


benchmark::idl::OwnerV2::OwnerV2()
{
    // string m_name
    m_name ="";
    // long m_age
    m_age = 0;

}

benchmark::idl::OwnerV2::~OwnerV2()
{


}

benchmark::idl::OwnerV2::OwnerV2(
        const OwnerV2& x)
{
    m_name = x.m_name;
    m_age = x.m_age;
}

benchmark::idl::OwnerV2::OwnerV2(
        OwnerV2&& x) noexcept 
{
    m_name = std::move(x.m_name);
    m_age = x.m_age;
}

benchmark::idl::OwnerV2& benchmark::idl::OwnerV2::operator =(
        const OwnerV2& x)
{

    m_name = x.m_name;
    m_age = x.m_age;

    return *this;
}

benchmark::idl::OwnerV2& benchmark::idl::OwnerV2::operator =(
        OwnerV2&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_age = x.m_age;

    return *this;
}

bool benchmark::idl::OwnerV2::operator ==(
        const OwnerV2& x) const
{

    return (m_name == x.m_name && m_age == x.m_age);
}

bool benchmark::idl::OwnerV2::operator !=(
        const OwnerV2& x) const
{
    return !(*this == x);
}

size_t benchmark::idl::OwnerV2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV2_max_cdr_typesize;
}

size_t benchmark::idl::OwnerV2::getCdrSerializedSize(
        const benchmark::idl::OwnerV2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void benchmark::idl::OwnerV2::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name.c_str();
    scdr << m_age;

}

void benchmark::idl::OwnerV2::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_age;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void benchmark::idl::OwnerV2::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void benchmark::idl::OwnerV2::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& benchmark::idl::OwnerV2::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& benchmark::idl::OwnerV2::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member age
 * @param _age New value for member age
 */
void benchmark::idl::OwnerV2::age(
        int32_t _age)
{
    m_age = _age;
}

/*!
 * @brief This function returns the value of member age
 * @return Value of member age
 */
int32_t benchmark::idl::OwnerV2::age() const
{
    return m_age;
}

/*!
 * @brief This function returns a reference to member age
 * @return Reference to member age
 */
int32_t& benchmark::idl::OwnerV2::age()
{
    return m_age;
}



size_t benchmark::idl::OwnerV2::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV2_max_key_cdr_typesize;
}

bool benchmark::idl::OwnerV2::isKeyDefined()
{
    return false;
}

void benchmark::idl::OwnerV2::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


benchmark::idl::OwnerV3::OwnerV3()
{
    // string m_name
    m_name ="";
    // long m_age
    m_age = 0;

}

benchmark::idl::OwnerV3::~OwnerV3()
{


}

benchmark::idl::OwnerV3::OwnerV3(
        const OwnerV3& x)
{
    m_name = x.m_name;
    m_age = x.m_age;
}

benchmark::idl::OwnerV3::OwnerV3(
        OwnerV3&& x) noexcept 
{
    m_name = std::move(x.m_name);
    m_age = x.m_age;
}

benchmark::idl::OwnerV3& benchmark::idl::OwnerV3::operator =(
        const OwnerV3& x)
{

    m_name = x.m_name;
    m_age = x.m_age;

    return *this;
}

benchmark::idl::OwnerV3& benchmark::idl::OwnerV3::operator =(
        OwnerV3&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_age = x.m_age;

    return *this;
}

bool benchmark::idl::OwnerV3::operator ==(
        const OwnerV3& x) const
{

    return (m_name == x.m_name && m_age == x.m_age);
}

bool benchmark::idl::OwnerV3::operator !=(
        const OwnerV3& x) const
{
    return !(*this == x);
}

size_t benchmark::idl::OwnerV3::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV3_max_cdr_typesize;
}

size_t benchmark::idl::OwnerV3::getCdrSerializedSize(
        const benchmark::idl::OwnerV3& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void benchmark::idl::OwnerV3::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name.c_str();
    scdr << m_age;

}

void benchmark::idl::OwnerV3::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_age;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void benchmark::idl::OwnerV3::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void benchmark::idl::OwnerV3::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& benchmark::idl::OwnerV3::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& benchmark::idl::OwnerV3::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member age
 * @param _age New value for member age
 */
void benchmark::idl::OwnerV3::age(
        int32_t _age)
{
    m_age = _age;
}

/*!
 * @brief This function returns the value of member age
 * @return Value of member age
 */
int32_t benchmark::idl::OwnerV3::age() const
{
    return m_age;
}

/*!
 * @brief This function returns a reference to member age
 * @return Reference to member age
 */
int32_t& benchmark::idl::OwnerV3::age()
{
    return m_age;
}



size_t benchmark::idl::OwnerV3::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV3_max_key_cdr_typesize;
}

bool benchmark::idl::OwnerV3::isKeyDefined()
{
    return false;
}

void benchmark::idl::OwnerV3::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


benchmark::idl::OwnerV4::OwnerV4()
{
    // string m_name
    m_name ="";
    // long m_age
    m_age = 0;

}

benchmark::idl::OwnerV4::~OwnerV4()
{


}

benchmark::idl::OwnerV4::OwnerV4(
        const OwnerV4& x)
{
    m_name = x.m_name;
    m_age = x.m_age;
}

benchmark::idl::OwnerV4::OwnerV4(
        OwnerV4&& x) noexcept 
{
    m_name = std::move(x.m_name);
    m_age = x.m_age;
}

benchmark::idl::OwnerV4& benchmark::idl::OwnerV4::operator =(
        const OwnerV4& x)
{

    m_name = x.m_name;
    m_age = x.m_age;

    return *this;
}

benchmark::idl::OwnerV4& benchmark::idl::OwnerV4::operator =(
        OwnerV4&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_age = x.m_age;

    return *this;
}

bool benchmark::idl::OwnerV4::operator ==(
        const OwnerV4& x) const
{

    return (m_name == x.m_name && m_age == x.m_age);
}

bool benchmark::idl::OwnerV4::operator !=(
        const OwnerV4& x) const
{
    return !(*this == x);
}

size_t benchmark::idl::OwnerV4::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV4_max_cdr_typesize;
}

size_t benchmark::idl::OwnerV4::getCdrSerializedSize(
        const benchmark::idl::OwnerV4& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void benchmark::idl::OwnerV4::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name.c_str();
    scdr << m_age;

}

void benchmark::idl::OwnerV4::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_age;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void benchmark::idl::OwnerV4::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void benchmark::idl::OwnerV4::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& benchmark::idl::OwnerV4::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& benchmark::idl::OwnerV4::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member age
 * @param _age New value for member age
 */
void benchmark::idl::OwnerV4::age(
        int32_t _age)
{
    m_age = _age;
}

/*!
 * @brief This function returns the value of member age
 * @return Value of member age
 */
int32_t benchmark::idl::OwnerV4::age() const
{
    return m_age;
}

/*!
 * @brief This function returns a reference to member age
 * @return Reference to member age
 */
int32_t& benchmark::idl::OwnerV4::age()
{
    return m_age;
}



size_t benchmark::idl::OwnerV4::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_OwnerV4_max_key_cdr_typesize;
}

bool benchmark::idl::OwnerV4::isKeyDefined()
{
    return false;
}

void benchmark::idl::OwnerV4::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


benchmark::idl::Pet::Pet()
{
    // double m_d
    m_d = 0.0;
    // float m_f
    m_f = 0.0;
    // long m_i32
    m_i32 = 0;
    // long long m_i64
    m_i64 = 0;
    // unsigned long m_u32
    m_u32 = 0;
    // unsigned long long m_u64
    m_u64 = 0;
    // boolean m_bval
    m_bval = false;
    // string m_s
    m_s ="";
    // double m_arr_d
    memset(&m_arr_d, 0, (10000) * 8);
    // float m_arr_f
    memset(&m_arr_f, 0, (10000) * 4);
    // long m_arr_i32
    memset(&m_arr_i32, 0, (10000) * 4);
    // long long m_arr_i64
    memset(&m_arr_i64, 0, (10000) * 8);
    // unsigned long m_arr_u32
    memset(&m_arr_u32, 0, (10000) * 4);
    // unsigned long long m_arr_u64
    memset(&m_arr_u64, 0, (10000) * 8);
    // boolean m_arr_bval
    memset(&m_arr_bval, 0, (10000) * 1);
    // string m_arr_s

    // sequence<double> m_vec_d

    // sequence<float> m_vec_f

    // sequence<long> m_vec_i32

    // sequence<long long> m_vec_i64

    // sequence<unsigned long> m_vec_u32

    // sequence<unsigned long long> m_vec_u64

    // sequence<boolean> m_vec_bval

    // sequence<string> m_vec_s

    // benchmark::idl::Owner m_own

    // benchmark::idl::Owner m_arr_own

    // sequence<benchmark::idl::Owner> m_vec_own

    // benchmark::idl::OwnerV2 m_own_v2

    // benchmark::idl::OwnerV2 m_arr_own_v2

    // sequence<benchmark::idl::OwnerV2> m_vec_own_v2

    // benchmark::idl::OwnerV3 m_own_v3

    // benchmark::idl::OwnerV3 m_arr_own_v3

    // sequence<benchmark::idl::OwnerV3> m_vec_own_v3

    // benchmark::idl::OwnerV4 m_own_v4

    // benchmark::idl::OwnerV4 m_arr_own_v4

    // sequence<benchmark::idl::OwnerV4> m_vec_own_v4

    // benchmark::idl::PetType m_pet_type
    m_pet_type = benchmark::idl::DOG;
    // benchmark::idl::PetType m_arr_pet_type
    memset(&m_arr_pet_type, 0, (10000) * 4);
    // sequence<benchmark::idl::PetType> m_vec_pet_type

    // octet m_arr_u8
    memset(&m_arr_u8, 0, (10000) * 1);

}

benchmark::idl::Pet::~Pet()
{








































}

benchmark::idl::Pet::Pet(
        const Pet& x)
{
    m_d = x.m_d;
    m_f = x.m_f;
    m_i32 = x.m_i32;
    m_i64 = x.m_i64;
    m_u32 = x.m_u32;
    m_u64 = x.m_u64;
    m_bval = x.m_bval;
    m_s = x.m_s;
    m_arr_d = x.m_arr_d;
    m_arr_f = x.m_arr_f;
    m_arr_i32 = x.m_arr_i32;
    m_arr_i64 = x.m_arr_i64;
    m_arr_u32 = x.m_arr_u32;
    m_arr_u64 = x.m_arr_u64;
    m_arr_bval = x.m_arr_bval;
    m_arr_s = x.m_arr_s;
    m_vec_d = x.m_vec_d;
    m_vec_f = x.m_vec_f;
    m_vec_i32 = x.m_vec_i32;
    m_vec_i64 = x.m_vec_i64;
    m_vec_u32 = x.m_vec_u32;
    m_vec_u64 = x.m_vec_u64;
    m_vec_bval = x.m_vec_bval;
    m_vec_s = x.m_vec_s;
    m_own = x.m_own;
    m_arr_own = x.m_arr_own;
    m_vec_own = x.m_vec_own;
    m_own_v2 = x.m_own_v2;
    m_arr_own_v2 = x.m_arr_own_v2;
    m_vec_own_v2 = x.m_vec_own_v2;
    m_own_v3 = x.m_own_v3;
    m_arr_own_v3 = x.m_arr_own_v3;
    m_vec_own_v3 = x.m_vec_own_v3;
    m_own_v4 = x.m_own_v4;
    m_arr_own_v4 = x.m_arr_own_v4;
    m_vec_own_v4 = x.m_vec_own_v4;
    m_pet_type = x.m_pet_type;
    m_arr_pet_type = x.m_arr_pet_type;
    m_vec_pet_type = x.m_vec_pet_type;
    m_arr_u8 = x.m_arr_u8;
}

benchmark::idl::Pet::Pet(
        Pet&& x) noexcept 
{
    m_d = x.m_d;
    m_f = x.m_f;
    m_i32 = x.m_i32;
    m_i64 = x.m_i64;
    m_u32 = x.m_u32;
    m_u64 = x.m_u64;
    m_bval = x.m_bval;
    m_s = std::move(x.m_s);
    m_arr_d = std::move(x.m_arr_d);
    m_arr_f = std::move(x.m_arr_f);
    m_arr_i32 = std::move(x.m_arr_i32);
    m_arr_i64 = std::move(x.m_arr_i64);
    m_arr_u32 = std::move(x.m_arr_u32);
    m_arr_u64 = std::move(x.m_arr_u64);
    m_arr_bval = std::move(x.m_arr_bval);
    m_arr_s = std::move(x.m_arr_s);
    m_vec_d = std::move(x.m_vec_d);
    m_vec_f = std::move(x.m_vec_f);
    m_vec_i32 = std::move(x.m_vec_i32);
    m_vec_i64 = std::move(x.m_vec_i64);
    m_vec_u32 = std::move(x.m_vec_u32);
    m_vec_u64 = std::move(x.m_vec_u64);
    m_vec_bval = std::move(x.m_vec_bval);
    m_vec_s = std::move(x.m_vec_s);
    m_own = std::move(x.m_own);
    m_arr_own = std::move(x.m_arr_own);
    m_vec_own = std::move(x.m_vec_own);
    m_own_v2 = std::move(x.m_own_v2);
    m_arr_own_v2 = std::move(x.m_arr_own_v2);
    m_vec_own_v2 = std::move(x.m_vec_own_v2);
    m_own_v3 = std::move(x.m_own_v3);
    m_arr_own_v3 = std::move(x.m_arr_own_v3);
    m_vec_own_v3 = std::move(x.m_vec_own_v3);
    m_own_v4 = std::move(x.m_own_v4);
    m_arr_own_v4 = std::move(x.m_arr_own_v4);
    m_vec_own_v4 = std::move(x.m_vec_own_v4);
    m_pet_type = x.m_pet_type;
    m_arr_pet_type = std::move(x.m_arr_pet_type);
    m_vec_pet_type = std::move(x.m_vec_pet_type);
    m_arr_u8 = std::move(x.m_arr_u8);
}

benchmark::idl::Pet& benchmark::idl::Pet::operator =(
        const Pet& x)
{

    m_d = x.m_d;
    m_f = x.m_f;
    m_i32 = x.m_i32;
    m_i64 = x.m_i64;
    m_u32 = x.m_u32;
    m_u64 = x.m_u64;
    m_bval = x.m_bval;
    m_s = x.m_s;
    m_arr_d = x.m_arr_d;
    m_arr_f = x.m_arr_f;
    m_arr_i32 = x.m_arr_i32;
    m_arr_i64 = x.m_arr_i64;
    m_arr_u32 = x.m_arr_u32;
    m_arr_u64 = x.m_arr_u64;
    m_arr_bval = x.m_arr_bval;
    m_arr_s = x.m_arr_s;
    m_vec_d = x.m_vec_d;
    m_vec_f = x.m_vec_f;
    m_vec_i32 = x.m_vec_i32;
    m_vec_i64 = x.m_vec_i64;
    m_vec_u32 = x.m_vec_u32;
    m_vec_u64 = x.m_vec_u64;
    m_vec_bval = x.m_vec_bval;
    m_vec_s = x.m_vec_s;
    m_own = x.m_own;
    m_arr_own = x.m_arr_own;
    m_vec_own = x.m_vec_own;
    m_own_v2 = x.m_own_v2;
    m_arr_own_v2 = x.m_arr_own_v2;
    m_vec_own_v2 = x.m_vec_own_v2;
    m_own_v3 = x.m_own_v3;
    m_arr_own_v3 = x.m_arr_own_v3;
    m_vec_own_v3 = x.m_vec_own_v3;
    m_own_v4 = x.m_own_v4;
    m_arr_own_v4 = x.m_arr_own_v4;
    m_vec_own_v4 = x.m_vec_own_v4;
    m_pet_type = x.m_pet_type;
    m_arr_pet_type = x.m_arr_pet_type;
    m_vec_pet_type = x.m_vec_pet_type;
    m_arr_u8 = x.m_arr_u8;

    return *this;
}

benchmark::idl::Pet& benchmark::idl::Pet::operator =(
        Pet&& x) noexcept
{

    m_d = x.m_d;
    m_f = x.m_f;
    m_i32 = x.m_i32;
    m_i64 = x.m_i64;
    m_u32 = x.m_u32;
    m_u64 = x.m_u64;
    m_bval = x.m_bval;
    m_s = std::move(x.m_s);
    m_arr_d = std::move(x.m_arr_d);
    m_arr_f = std::move(x.m_arr_f);
    m_arr_i32 = std::move(x.m_arr_i32);
    m_arr_i64 = std::move(x.m_arr_i64);
    m_arr_u32 = std::move(x.m_arr_u32);
    m_arr_u64 = std::move(x.m_arr_u64);
    m_arr_bval = std::move(x.m_arr_bval);
    m_arr_s = std::move(x.m_arr_s);
    m_vec_d = std::move(x.m_vec_d);
    m_vec_f = std::move(x.m_vec_f);
    m_vec_i32 = std::move(x.m_vec_i32);
    m_vec_i64 = std::move(x.m_vec_i64);
    m_vec_u32 = std::move(x.m_vec_u32);
    m_vec_u64 = std::move(x.m_vec_u64);
    m_vec_bval = std::move(x.m_vec_bval);
    m_vec_s = std::move(x.m_vec_s);
    m_own = std::move(x.m_own);
    m_arr_own = std::move(x.m_arr_own);
    m_vec_own = std::move(x.m_vec_own);
    m_own_v2 = std::move(x.m_own_v2);
    m_arr_own_v2 = std::move(x.m_arr_own_v2);
    m_vec_own_v2 = std::move(x.m_vec_own_v2);
    m_own_v3 = std::move(x.m_own_v3);
    m_arr_own_v3 = std::move(x.m_arr_own_v3);
    m_vec_own_v3 = std::move(x.m_vec_own_v3);
    m_own_v4 = std::move(x.m_own_v4);
    m_arr_own_v4 = std::move(x.m_arr_own_v4);
    m_vec_own_v4 = std::move(x.m_vec_own_v4);
    m_pet_type = x.m_pet_type;
    m_arr_pet_type = std::move(x.m_arr_pet_type);
    m_vec_pet_type = std::move(x.m_vec_pet_type);
    m_arr_u8 = std::move(x.m_arr_u8);

    return *this;
}

bool benchmark::idl::Pet::operator ==(
        const Pet& x) const
{

    return (m_d == x.m_d && m_f == x.m_f && m_i32 == x.m_i32 && m_i64 == x.m_i64 && m_u32 == x.m_u32 && m_u64 == x.m_u64 && m_bval == x.m_bval && m_s == x.m_s && m_arr_d == x.m_arr_d && m_arr_f == x.m_arr_f && m_arr_i32 == x.m_arr_i32 && m_arr_i64 == x.m_arr_i64 && m_arr_u32 == x.m_arr_u32 && m_arr_u64 == x.m_arr_u64 && m_arr_bval == x.m_arr_bval && m_arr_s == x.m_arr_s && m_vec_d == x.m_vec_d && m_vec_f == x.m_vec_f && m_vec_i32 == x.m_vec_i32 && m_vec_i64 == x.m_vec_i64 && m_vec_u32 == x.m_vec_u32 && m_vec_u64 == x.m_vec_u64 && m_vec_bval == x.m_vec_bval && m_vec_s == x.m_vec_s && m_own == x.m_own && m_arr_own == x.m_arr_own && m_vec_own == x.m_vec_own && m_own_v2 == x.m_own_v2 && m_arr_own_v2 == x.m_arr_own_v2 && m_vec_own_v2 == x.m_vec_own_v2 && m_own_v3 == x.m_own_v3 && m_arr_own_v3 == x.m_arr_own_v3 && m_vec_own_v3 == x.m_vec_own_v3 && m_own_v4 == x.m_own_v4 && m_arr_own_v4 == x.m_arr_own_v4 && m_vec_own_v4 == x.m_vec_own_v4 && m_pet_type == x.m_pet_type && m_arr_pet_type == x.m_arr_pet_type && m_vec_pet_type == x.m_vec_pet_type && m_arr_u8 == x.m_arr_u8);
}

bool benchmark::idl::Pet::operator !=(
        const Pet& x) const
{
    return !(*this == x);
}

size_t benchmark::idl::Pet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_Pet_max_cdr_typesize;
}

size_t benchmark::idl::Pet::getCdrSerializedSize(
        const benchmark::idl::Pet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.s().size() + 1;

    current_alignment += ((10000) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += ((10000) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += ((10000) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += ((10000) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += ((10000) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += ((10000) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += ((10000) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    for(size_t a = 0; a < data.arr_s().size(); ++a)
    {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.arr_s().at(a).size() + 1;

    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_d().size() > 0)
    {
        current_alignment += (data.vec_d().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_f().size() > 0)
    {
        current_alignment += (data.vec_f().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_i32().size() > 0)
    {
        current_alignment += (data.vec_i32().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_i64().size() > 0)
    {
        current_alignment += (data.vec_i64().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_u32().size() > 0)
    {
        current_alignment += (data.vec_u32().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_u64().size() > 0)
    {
        current_alignment += (data.vec_u64().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_bval().size() > 0)
    {
        current_alignment += (data.vec_bval().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.vec_s().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
            data.vec_s().at(a).size() + 1;
    }
    current_alignment += benchmark::idl::Owner::getCdrSerializedSize(data.own(), current_alignment);

    for(size_t a = 0; a < data.arr_own().size(); ++a)
    {
            current_alignment += benchmark::idl::Owner::getCdrSerializedSize(data.arr_own().at(a), current_alignment);
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.vec_own().size(); ++a)
    {
        current_alignment += benchmark::idl::Owner::getCdrSerializedSize(data.vec_own().at(a), current_alignment);}

    current_alignment += benchmark::idl::OwnerV2::getCdrSerializedSize(data.own_v2(), current_alignment);

    for(size_t a = 0; a < data.arr_own_v2().size(); ++a)
    {
            current_alignment += benchmark::idl::OwnerV2::getCdrSerializedSize(data.arr_own_v2().at(a), current_alignment);
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.vec_own_v2().size(); ++a)
    {
        current_alignment += benchmark::idl::OwnerV2::getCdrSerializedSize(data.vec_own_v2().at(a), current_alignment);}

    current_alignment += benchmark::idl::OwnerV3::getCdrSerializedSize(data.own_v3(), current_alignment);

    for(size_t a = 0; a < data.arr_own_v3().size(); ++a)
    {
            current_alignment += benchmark::idl::OwnerV3::getCdrSerializedSize(data.arr_own_v3().at(a), current_alignment);
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.vec_own_v3().size(); ++a)
    {
        current_alignment += benchmark::idl::OwnerV3::getCdrSerializedSize(data.vec_own_v3().at(a), current_alignment);}

    current_alignment += benchmark::idl::OwnerV4::getCdrSerializedSize(data.own_v4(), current_alignment);

    for(size_t a = 0; a < data.arr_own_v4().size(); ++a)
    {
            current_alignment += benchmark::idl::OwnerV4::getCdrSerializedSize(data.arr_own_v4().at(a), current_alignment);
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.vec_own_v4().size(); ++a)
    {
        current_alignment += benchmark::idl::OwnerV4::getCdrSerializedSize(data.vec_own_v4().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((10000) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.vec_pet_type().size() > 0)
    {
        current_alignment += (data.vec_pet_type().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += ((10000) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void benchmark::idl::Pet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_d;
    scdr << m_f;
    scdr << m_i32;
    scdr << m_i64;
    scdr << m_u32;
    scdr << m_u64;
    scdr << m_bval;
    scdr << m_s.c_str();
    scdr << m_arr_d;

    scdr << m_arr_f;

    scdr << m_arr_i32;

    scdr << m_arr_i64;

    scdr << m_arr_u32;

    scdr << m_arr_u64;

    scdr << m_arr_bval;

    for (const auto& str : m_arr_s)
    {
        scdr << str.c_str();
    }


    scdr << m_vec_d;
    scdr << m_vec_f;
    scdr << m_vec_i32;
    scdr << m_vec_i64;
    scdr << m_vec_u32;
    scdr << m_vec_u64;
    scdr << m_vec_bval;
    scdr << m_vec_s;
    scdr << m_own;
    scdr << m_arr_own;

    scdr << m_vec_own;
    scdr << m_own_v2;
    scdr << m_arr_own_v2;

    scdr << m_vec_own_v2;
    scdr << m_own_v3;
    scdr << m_arr_own_v3;

    scdr << m_vec_own_v3;
    scdr << m_own_v4;
    scdr << m_arr_own_v4;

    scdr << m_vec_own_v4;
    scdr << (uint32_t)m_pet_type;
    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_arr_pet_type.data()), m_arr_pet_type.size());


    scdr << static_cast<uint32_t>(m_vec_pet_type.size());
    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_vec_pet_type.data()), m_vec_pet_type.size());

    scdr << m_arr_u8;


}

void benchmark::idl::Pet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_d;
    dcdr >> m_f;
    dcdr >> m_i32;
    dcdr >> m_i64;
    dcdr >> m_u32;
    dcdr >> m_u64;
    dcdr >> m_bval;
    dcdr >> m_s;
    dcdr >> m_arr_d;

    dcdr >> m_arr_f;

    dcdr >> m_arr_i32;

    dcdr >> m_arr_i64;

    dcdr >> m_arr_u32;

    dcdr >> m_arr_u64;

    dcdr >> m_arr_bval;

    for (auto& str : m_arr_s)
    {
        dcdr >> str;}


    dcdr >> m_vec_d;
    dcdr >> m_vec_f;
    dcdr >> m_vec_i32;
    dcdr >> m_vec_i64;
    dcdr >> m_vec_u32;
    dcdr >> m_vec_u64;
    dcdr >> m_vec_bval;
    dcdr >> m_vec_s;
    dcdr >> m_own;
    dcdr >> m_arr_own;

    dcdr >> m_vec_own;
    dcdr >> m_own_v2;
    dcdr >> m_arr_own_v2;

    dcdr >> m_vec_own_v2;
    dcdr >> m_own_v3;
    dcdr >> m_arr_own_v3;

    dcdr >> m_vec_own_v3;
    dcdr >> m_own_v4;
    dcdr >> m_arr_own_v4;

    dcdr >> m_vec_own_v4;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pet_type = (benchmark::idl::PetType)enum_value;
    }

    dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_arr_pet_type.data()), m_arr_pet_type.size());


    {
        uint32_t seq_length = 0;
        dcdr >> seq_length;
        m_vec_pet_type.resize(seq_length);
        dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_vec_pet_type.data()), seq_length);
    }

    dcdr >> m_arr_u8;

}

/*!
 * @brief This function sets a value in member d
 * @param _d New value for member d
 */
void benchmark::idl::Pet::d(
        double _d)
{
    m_d = _d;
}

/*!
 * @brief This function returns the value of member d
 * @return Value of member d
 */
double benchmark::idl::Pet::d() const
{
    return m_d;
}

/*!
 * @brief This function returns a reference to member d
 * @return Reference to member d
 */
double& benchmark::idl::Pet::d()
{
    return m_d;
}

/*!
 * @brief This function sets a value in member f
 * @param _f New value for member f
 */
void benchmark::idl::Pet::f(
        float _f)
{
    m_f = _f;
}

/*!
 * @brief This function returns the value of member f
 * @return Value of member f
 */
float benchmark::idl::Pet::f() const
{
    return m_f;
}

/*!
 * @brief This function returns a reference to member f
 * @return Reference to member f
 */
float& benchmark::idl::Pet::f()
{
    return m_f;
}

/*!
 * @brief This function sets a value in member i32
 * @param _i32 New value for member i32
 */
void benchmark::idl::Pet::i32(
        int32_t _i32)
{
    m_i32 = _i32;
}

/*!
 * @brief This function returns the value of member i32
 * @return Value of member i32
 */
int32_t benchmark::idl::Pet::i32() const
{
    return m_i32;
}

/*!
 * @brief This function returns a reference to member i32
 * @return Reference to member i32
 */
int32_t& benchmark::idl::Pet::i32()
{
    return m_i32;
}

/*!
 * @brief This function sets a value in member i64
 * @param _i64 New value for member i64
 */
void benchmark::idl::Pet::i64(
        int64_t _i64)
{
    m_i64 = _i64;
}

/*!
 * @brief This function returns the value of member i64
 * @return Value of member i64
 */
int64_t benchmark::idl::Pet::i64() const
{
    return m_i64;
}

/*!
 * @brief This function returns a reference to member i64
 * @return Reference to member i64
 */
int64_t& benchmark::idl::Pet::i64()
{
    return m_i64;
}

/*!
 * @brief This function sets a value in member u32
 * @param _u32 New value for member u32
 */
void benchmark::idl::Pet::u32(
        uint32_t _u32)
{
    m_u32 = _u32;
}

/*!
 * @brief This function returns the value of member u32
 * @return Value of member u32
 */
uint32_t benchmark::idl::Pet::u32() const
{
    return m_u32;
}

/*!
 * @brief This function returns a reference to member u32
 * @return Reference to member u32
 */
uint32_t& benchmark::idl::Pet::u32()
{
    return m_u32;
}

/*!
 * @brief This function sets a value in member u64
 * @param _u64 New value for member u64
 */
void benchmark::idl::Pet::u64(
        uint64_t _u64)
{
    m_u64 = _u64;
}

/*!
 * @brief This function returns the value of member u64
 * @return Value of member u64
 */
uint64_t benchmark::idl::Pet::u64() const
{
    return m_u64;
}

/*!
 * @brief This function returns a reference to member u64
 * @return Reference to member u64
 */
uint64_t& benchmark::idl::Pet::u64()
{
    return m_u64;
}

/*!
 * @brief This function sets a value in member bval
 * @param _bval New value for member bval
 */
void benchmark::idl::Pet::bval(
        bool _bval)
{
    m_bval = _bval;
}

/*!
 * @brief This function returns the value of member bval
 * @return Value of member bval
 */
bool benchmark::idl::Pet::bval() const
{
    return m_bval;
}

/*!
 * @brief This function returns a reference to member bval
 * @return Reference to member bval
 */
bool& benchmark::idl::Pet::bval()
{
    return m_bval;
}

/*!
 * @brief This function copies the value in member s
 * @param _s New value to be copied in member s
 */
void benchmark::idl::Pet::s(
        const std::string& _s)
{
    m_s = _s;
}

/*!
 * @brief This function moves the value in member s
 * @param _s New value to be moved in member s
 */
void benchmark::idl::Pet::s(
        std::string&& _s)
{
    m_s = std::move(_s);
}

/*!
 * @brief This function returns a constant reference to member s
 * @return Constant reference to member s
 */
const std::string& benchmark::idl::Pet::s() const
{
    return m_s;
}

/*!
 * @brief This function returns a reference to member s
 * @return Reference to member s
 */
std::string& benchmark::idl::Pet::s()
{
    return m_s;
}
/*!
 * @brief This function copies the value in member arr_d
 * @param _arr_d New value to be copied in member arr_d
 */
void benchmark::idl::Pet::arr_d(
        const std::array<double, 10000>& _arr_d)
{
    m_arr_d = _arr_d;
}

/*!
 * @brief This function moves the value in member arr_d
 * @param _arr_d New value to be moved in member arr_d
 */
void benchmark::idl::Pet::arr_d(
        std::array<double, 10000>&& _arr_d)
{
    m_arr_d = std::move(_arr_d);
}

/*!
 * @brief This function returns a constant reference to member arr_d
 * @return Constant reference to member arr_d
 */
const std::array<double, 10000>& benchmark::idl::Pet::arr_d() const
{
    return m_arr_d;
}

/*!
 * @brief This function returns a reference to member arr_d
 * @return Reference to member arr_d
 */
std::array<double, 10000>& benchmark::idl::Pet::arr_d()
{
    return m_arr_d;
}
/*!
 * @brief This function copies the value in member arr_f
 * @param _arr_f New value to be copied in member arr_f
 */
void benchmark::idl::Pet::arr_f(
        const std::array<float, 10000>& _arr_f)
{
    m_arr_f = _arr_f;
}

/*!
 * @brief This function moves the value in member arr_f
 * @param _arr_f New value to be moved in member arr_f
 */
void benchmark::idl::Pet::arr_f(
        std::array<float, 10000>&& _arr_f)
{
    m_arr_f = std::move(_arr_f);
}

/*!
 * @brief This function returns a constant reference to member arr_f
 * @return Constant reference to member arr_f
 */
const std::array<float, 10000>& benchmark::idl::Pet::arr_f() const
{
    return m_arr_f;
}

/*!
 * @brief This function returns a reference to member arr_f
 * @return Reference to member arr_f
 */
std::array<float, 10000>& benchmark::idl::Pet::arr_f()
{
    return m_arr_f;
}
/*!
 * @brief This function copies the value in member arr_i32
 * @param _arr_i32 New value to be copied in member arr_i32
 */
void benchmark::idl::Pet::arr_i32(
        const std::array<int32_t, 10000>& _arr_i32)
{
    m_arr_i32 = _arr_i32;
}

/*!
 * @brief This function moves the value in member arr_i32
 * @param _arr_i32 New value to be moved in member arr_i32
 */
void benchmark::idl::Pet::arr_i32(
        std::array<int32_t, 10000>&& _arr_i32)
{
    m_arr_i32 = std::move(_arr_i32);
}

/*!
 * @brief This function returns a constant reference to member arr_i32
 * @return Constant reference to member arr_i32
 */
const std::array<int32_t, 10000>& benchmark::idl::Pet::arr_i32() const
{
    return m_arr_i32;
}

/*!
 * @brief This function returns a reference to member arr_i32
 * @return Reference to member arr_i32
 */
std::array<int32_t, 10000>& benchmark::idl::Pet::arr_i32()
{
    return m_arr_i32;
}
/*!
 * @brief This function copies the value in member arr_i64
 * @param _arr_i64 New value to be copied in member arr_i64
 */
void benchmark::idl::Pet::arr_i64(
        const std::array<int64_t, 10000>& _arr_i64)
{
    m_arr_i64 = _arr_i64;
}

/*!
 * @brief This function moves the value in member arr_i64
 * @param _arr_i64 New value to be moved in member arr_i64
 */
void benchmark::idl::Pet::arr_i64(
        std::array<int64_t, 10000>&& _arr_i64)
{
    m_arr_i64 = std::move(_arr_i64);
}

/*!
 * @brief This function returns a constant reference to member arr_i64
 * @return Constant reference to member arr_i64
 */
const std::array<int64_t, 10000>& benchmark::idl::Pet::arr_i64() const
{
    return m_arr_i64;
}

/*!
 * @brief This function returns a reference to member arr_i64
 * @return Reference to member arr_i64
 */
std::array<int64_t, 10000>& benchmark::idl::Pet::arr_i64()
{
    return m_arr_i64;
}
/*!
 * @brief This function copies the value in member arr_u32
 * @param _arr_u32 New value to be copied in member arr_u32
 */
void benchmark::idl::Pet::arr_u32(
        const std::array<uint32_t, 10000>& _arr_u32)
{
    m_arr_u32 = _arr_u32;
}

/*!
 * @brief This function moves the value in member arr_u32
 * @param _arr_u32 New value to be moved in member arr_u32
 */
void benchmark::idl::Pet::arr_u32(
        std::array<uint32_t, 10000>&& _arr_u32)
{
    m_arr_u32 = std::move(_arr_u32);
}

/*!
 * @brief This function returns a constant reference to member arr_u32
 * @return Constant reference to member arr_u32
 */
const std::array<uint32_t, 10000>& benchmark::idl::Pet::arr_u32() const
{
    return m_arr_u32;
}

/*!
 * @brief This function returns a reference to member arr_u32
 * @return Reference to member arr_u32
 */
std::array<uint32_t, 10000>& benchmark::idl::Pet::arr_u32()
{
    return m_arr_u32;
}
/*!
 * @brief This function copies the value in member arr_u64
 * @param _arr_u64 New value to be copied in member arr_u64
 */
void benchmark::idl::Pet::arr_u64(
        const std::array<uint64_t, 10000>& _arr_u64)
{
    m_arr_u64 = _arr_u64;
}

/*!
 * @brief This function moves the value in member arr_u64
 * @param _arr_u64 New value to be moved in member arr_u64
 */
void benchmark::idl::Pet::arr_u64(
        std::array<uint64_t, 10000>&& _arr_u64)
{
    m_arr_u64 = std::move(_arr_u64);
}

/*!
 * @brief This function returns a constant reference to member arr_u64
 * @return Constant reference to member arr_u64
 */
const std::array<uint64_t, 10000>& benchmark::idl::Pet::arr_u64() const
{
    return m_arr_u64;
}

/*!
 * @brief This function returns a reference to member arr_u64
 * @return Reference to member arr_u64
 */
std::array<uint64_t, 10000>& benchmark::idl::Pet::arr_u64()
{
    return m_arr_u64;
}
/*!
 * @brief This function copies the value in member arr_bval
 * @param _arr_bval New value to be copied in member arr_bval
 */
void benchmark::idl::Pet::arr_bval(
        const std::array<bool, 10000>& _arr_bval)
{
    m_arr_bval = _arr_bval;
}

/*!
 * @brief This function moves the value in member arr_bval
 * @param _arr_bval New value to be moved in member arr_bval
 */
void benchmark::idl::Pet::arr_bval(
        std::array<bool, 10000>&& _arr_bval)
{
    m_arr_bval = std::move(_arr_bval);
}

/*!
 * @brief This function returns a constant reference to member arr_bval
 * @return Constant reference to member arr_bval
 */
const std::array<bool, 10000>& benchmark::idl::Pet::arr_bval() const
{
    return m_arr_bval;
}

/*!
 * @brief This function returns a reference to member arr_bval
 * @return Reference to member arr_bval
 */
std::array<bool, 10000>& benchmark::idl::Pet::arr_bval()
{
    return m_arr_bval;
}
/*!
 * @brief This function copies the value in member arr_s
 * @param _arr_s New value to be copied in member arr_s
 */
void benchmark::idl::Pet::arr_s(
        const std::array<std::string, 10000>& _arr_s)
{
    m_arr_s = _arr_s;
}

/*!
 * @brief This function moves the value in member arr_s
 * @param _arr_s New value to be moved in member arr_s
 */
void benchmark::idl::Pet::arr_s(
        std::array<std::string, 10000>&& _arr_s)
{
    m_arr_s = std::move(_arr_s);
}

/*!
 * @brief This function returns a constant reference to member arr_s
 * @return Constant reference to member arr_s
 */
const std::array<std::string, 10000>& benchmark::idl::Pet::arr_s() const
{
    return m_arr_s;
}

/*!
 * @brief This function returns a reference to member arr_s
 * @return Reference to member arr_s
 */
std::array<std::string, 10000>& benchmark::idl::Pet::arr_s()
{
    return m_arr_s;
}
/*!
 * @brief This function copies the value in member vec_d
 * @param _vec_d New value to be copied in member vec_d
 */
void benchmark::idl::Pet::vec_d(
        const std::vector<double>& _vec_d)
{
    m_vec_d = _vec_d;
}

/*!
 * @brief This function moves the value in member vec_d
 * @param _vec_d New value to be moved in member vec_d
 */
void benchmark::idl::Pet::vec_d(
        std::vector<double>&& _vec_d)
{
    m_vec_d = std::move(_vec_d);
}

/*!
 * @brief This function returns a constant reference to member vec_d
 * @return Constant reference to member vec_d
 */
const std::vector<double>& benchmark::idl::Pet::vec_d() const
{
    return m_vec_d;
}

/*!
 * @brief This function returns a reference to member vec_d
 * @return Reference to member vec_d
 */
std::vector<double>& benchmark::idl::Pet::vec_d()
{
    return m_vec_d;
}
/*!
 * @brief This function copies the value in member vec_f
 * @param _vec_f New value to be copied in member vec_f
 */
void benchmark::idl::Pet::vec_f(
        const std::vector<float>& _vec_f)
{
    m_vec_f = _vec_f;
}

/*!
 * @brief This function moves the value in member vec_f
 * @param _vec_f New value to be moved in member vec_f
 */
void benchmark::idl::Pet::vec_f(
        std::vector<float>&& _vec_f)
{
    m_vec_f = std::move(_vec_f);
}

/*!
 * @brief This function returns a constant reference to member vec_f
 * @return Constant reference to member vec_f
 */
const std::vector<float>& benchmark::idl::Pet::vec_f() const
{
    return m_vec_f;
}

/*!
 * @brief This function returns a reference to member vec_f
 * @return Reference to member vec_f
 */
std::vector<float>& benchmark::idl::Pet::vec_f()
{
    return m_vec_f;
}
/*!
 * @brief This function copies the value in member vec_i32
 * @param _vec_i32 New value to be copied in member vec_i32
 */
void benchmark::idl::Pet::vec_i32(
        const std::vector<int32_t>& _vec_i32)
{
    m_vec_i32 = _vec_i32;
}

/*!
 * @brief This function moves the value in member vec_i32
 * @param _vec_i32 New value to be moved in member vec_i32
 */
void benchmark::idl::Pet::vec_i32(
        std::vector<int32_t>&& _vec_i32)
{
    m_vec_i32 = std::move(_vec_i32);
}

/*!
 * @brief This function returns a constant reference to member vec_i32
 * @return Constant reference to member vec_i32
 */
const std::vector<int32_t>& benchmark::idl::Pet::vec_i32() const
{
    return m_vec_i32;
}

/*!
 * @brief This function returns a reference to member vec_i32
 * @return Reference to member vec_i32
 */
std::vector<int32_t>& benchmark::idl::Pet::vec_i32()
{
    return m_vec_i32;
}
/*!
 * @brief This function copies the value in member vec_i64
 * @param _vec_i64 New value to be copied in member vec_i64
 */
void benchmark::idl::Pet::vec_i64(
        const std::vector<int64_t>& _vec_i64)
{
    m_vec_i64 = _vec_i64;
}

/*!
 * @brief This function moves the value in member vec_i64
 * @param _vec_i64 New value to be moved in member vec_i64
 */
void benchmark::idl::Pet::vec_i64(
        std::vector<int64_t>&& _vec_i64)
{
    m_vec_i64 = std::move(_vec_i64);
}

/*!
 * @brief This function returns a constant reference to member vec_i64
 * @return Constant reference to member vec_i64
 */
const std::vector<int64_t>& benchmark::idl::Pet::vec_i64() const
{
    return m_vec_i64;
}

/*!
 * @brief This function returns a reference to member vec_i64
 * @return Reference to member vec_i64
 */
std::vector<int64_t>& benchmark::idl::Pet::vec_i64()
{
    return m_vec_i64;
}
/*!
 * @brief This function copies the value in member vec_u32
 * @param _vec_u32 New value to be copied in member vec_u32
 */
void benchmark::idl::Pet::vec_u32(
        const std::vector<uint32_t>& _vec_u32)
{
    m_vec_u32 = _vec_u32;
}

/*!
 * @brief This function moves the value in member vec_u32
 * @param _vec_u32 New value to be moved in member vec_u32
 */
void benchmark::idl::Pet::vec_u32(
        std::vector<uint32_t>&& _vec_u32)
{
    m_vec_u32 = std::move(_vec_u32);
}

/*!
 * @brief This function returns a constant reference to member vec_u32
 * @return Constant reference to member vec_u32
 */
const std::vector<uint32_t>& benchmark::idl::Pet::vec_u32() const
{
    return m_vec_u32;
}

/*!
 * @brief This function returns a reference to member vec_u32
 * @return Reference to member vec_u32
 */
std::vector<uint32_t>& benchmark::idl::Pet::vec_u32()
{
    return m_vec_u32;
}
/*!
 * @brief This function copies the value in member vec_u64
 * @param _vec_u64 New value to be copied in member vec_u64
 */
void benchmark::idl::Pet::vec_u64(
        const std::vector<uint64_t>& _vec_u64)
{
    m_vec_u64 = _vec_u64;
}

/*!
 * @brief This function moves the value in member vec_u64
 * @param _vec_u64 New value to be moved in member vec_u64
 */
void benchmark::idl::Pet::vec_u64(
        std::vector<uint64_t>&& _vec_u64)
{
    m_vec_u64 = std::move(_vec_u64);
}

/*!
 * @brief This function returns a constant reference to member vec_u64
 * @return Constant reference to member vec_u64
 */
const std::vector<uint64_t>& benchmark::idl::Pet::vec_u64() const
{
    return m_vec_u64;
}

/*!
 * @brief This function returns a reference to member vec_u64
 * @return Reference to member vec_u64
 */
std::vector<uint64_t>& benchmark::idl::Pet::vec_u64()
{
    return m_vec_u64;
}
/*!
 * @brief This function copies the value in member vec_bval
 * @param _vec_bval New value to be copied in member vec_bval
 */
void benchmark::idl::Pet::vec_bval(
        const std::vector<bool>& _vec_bval)
{
    m_vec_bval = _vec_bval;
}

/*!
 * @brief This function moves the value in member vec_bval
 * @param _vec_bval New value to be moved in member vec_bval
 */
void benchmark::idl::Pet::vec_bval(
        std::vector<bool>&& _vec_bval)
{
    m_vec_bval = std::move(_vec_bval);
}

/*!
 * @brief This function returns a constant reference to member vec_bval
 * @return Constant reference to member vec_bval
 */
const std::vector<bool>& benchmark::idl::Pet::vec_bval() const
{
    return m_vec_bval;
}

/*!
 * @brief This function returns a reference to member vec_bval
 * @return Reference to member vec_bval
 */
std::vector<bool>& benchmark::idl::Pet::vec_bval()
{
    return m_vec_bval;
}
/*!
 * @brief This function copies the value in member vec_s
 * @param _vec_s New value to be copied in member vec_s
 */
void benchmark::idl::Pet::vec_s(
        const std::vector<std::string>& _vec_s)
{
    m_vec_s = _vec_s;
}

/*!
 * @brief This function moves the value in member vec_s
 * @param _vec_s New value to be moved in member vec_s
 */
void benchmark::idl::Pet::vec_s(
        std::vector<std::string>&& _vec_s)
{
    m_vec_s = std::move(_vec_s);
}

/*!
 * @brief This function returns a constant reference to member vec_s
 * @return Constant reference to member vec_s
 */
const std::vector<std::string>& benchmark::idl::Pet::vec_s() const
{
    return m_vec_s;
}

/*!
 * @brief This function returns a reference to member vec_s
 * @return Reference to member vec_s
 */
std::vector<std::string>& benchmark::idl::Pet::vec_s()
{
    return m_vec_s;
}
/*!
 * @brief This function copies the value in member own
 * @param _own New value to be copied in member own
 */
void benchmark::idl::Pet::own(
        const benchmark::idl::Owner& _own)
{
    m_own = _own;
}

/*!
 * @brief This function moves the value in member own
 * @param _own New value to be moved in member own
 */
void benchmark::idl::Pet::own(
        benchmark::idl::Owner&& _own)
{
    m_own = std::move(_own);
}

/*!
 * @brief This function returns a constant reference to member own
 * @return Constant reference to member own
 */
const benchmark::idl::Owner& benchmark::idl::Pet::own() const
{
    return m_own;
}

/*!
 * @brief This function returns a reference to member own
 * @return Reference to member own
 */
benchmark::idl::Owner& benchmark::idl::Pet::own()
{
    return m_own;
}
/*!
 * @brief This function copies the value in member arr_own
 * @param _arr_own New value to be copied in member arr_own
 */
void benchmark::idl::Pet::arr_own(
        const std::array<benchmark::idl::Owner, 10000>& _arr_own)
{
    m_arr_own = _arr_own;
}

/*!
 * @brief This function moves the value in member arr_own
 * @param _arr_own New value to be moved in member arr_own
 */
void benchmark::idl::Pet::arr_own(
        std::array<benchmark::idl::Owner, 10000>&& _arr_own)
{
    m_arr_own = std::move(_arr_own);
}

/*!
 * @brief This function returns a constant reference to member arr_own
 * @return Constant reference to member arr_own
 */
const std::array<benchmark::idl::Owner, 10000>& benchmark::idl::Pet::arr_own() const
{
    return m_arr_own;
}

/*!
 * @brief This function returns a reference to member arr_own
 * @return Reference to member arr_own
 */
std::array<benchmark::idl::Owner, 10000>& benchmark::idl::Pet::arr_own()
{
    return m_arr_own;
}
/*!
 * @brief This function copies the value in member vec_own
 * @param _vec_own New value to be copied in member vec_own
 */
void benchmark::idl::Pet::vec_own(
        const std::vector<benchmark::idl::Owner>& _vec_own)
{
    m_vec_own = _vec_own;
}

/*!
 * @brief This function moves the value in member vec_own
 * @param _vec_own New value to be moved in member vec_own
 */
void benchmark::idl::Pet::vec_own(
        std::vector<benchmark::idl::Owner>&& _vec_own)
{
    m_vec_own = std::move(_vec_own);
}

/*!
 * @brief This function returns a constant reference to member vec_own
 * @return Constant reference to member vec_own
 */
const std::vector<benchmark::idl::Owner>& benchmark::idl::Pet::vec_own() const
{
    return m_vec_own;
}

/*!
 * @brief This function returns a reference to member vec_own
 * @return Reference to member vec_own
 */
std::vector<benchmark::idl::Owner>& benchmark::idl::Pet::vec_own()
{
    return m_vec_own;
}
/*!
 * @brief This function copies the value in member own_v2
 * @param _own_v2 New value to be copied in member own_v2
 */
void benchmark::idl::Pet::own_v2(
        const benchmark::idl::OwnerV2& _own_v2)
{
    m_own_v2 = _own_v2;
}

/*!
 * @brief This function moves the value in member own_v2
 * @param _own_v2 New value to be moved in member own_v2
 */
void benchmark::idl::Pet::own_v2(
        benchmark::idl::OwnerV2&& _own_v2)
{
    m_own_v2 = std::move(_own_v2);
}

/*!
 * @brief This function returns a constant reference to member own_v2
 * @return Constant reference to member own_v2
 */
const benchmark::idl::OwnerV2& benchmark::idl::Pet::own_v2() const
{
    return m_own_v2;
}

/*!
 * @brief This function returns a reference to member own_v2
 * @return Reference to member own_v2
 */
benchmark::idl::OwnerV2& benchmark::idl::Pet::own_v2()
{
    return m_own_v2;
}
/*!
 * @brief This function copies the value in member arr_own_v2
 * @param _arr_own_v2 New value to be copied in member arr_own_v2
 */
void benchmark::idl::Pet::arr_own_v2(
        const std::array<benchmark::idl::OwnerV2, 10000>& _arr_own_v2)
{
    m_arr_own_v2 = _arr_own_v2;
}

/*!
 * @brief This function moves the value in member arr_own_v2
 * @param _arr_own_v2 New value to be moved in member arr_own_v2
 */
void benchmark::idl::Pet::arr_own_v2(
        std::array<benchmark::idl::OwnerV2, 10000>&& _arr_own_v2)
{
    m_arr_own_v2 = std::move(_arr_own_v2);
}

/*!
 * @brief This function returns a constant reference to member arr_own_v2
 * @return Constant reference to member arr_own_v2
 */
const std::array<benchmark::idl::OwnerV2, 10000>& benchmark::idl::Pet::arr_own_v2() const
{
    return m_arr_own_v2;
}

/*!
 * @brief This function returns a reference to member arr_own_v2
 * @return Reference to member arr_own_v2
 */
std::array<benchmark::idl::OwnerV2, 10000>& benchmark::idl::Pet::arr_own_v2()
{
    return m_arr_own_v2;
}
/*!
 * @brief This function copies the value in member vec_own_v2
 * @param _vec_own_v2 New value to be copied in member vec_own_v2
 */
void benchmark::idl::Pet::vec_own_v2(
        const std::vector<benchmark::idl::OwnerV2>& _vec_own_v2)
{
    m_vec_own_v2 = _vec_own_v2;
}

/*!
 * @brief This function moves the value in member vec_own_v2
 * @param _vec_own_v2 New value to be moved in member vec_own_v2
 */
void benchmark::idl::Pet::vec_own_v2(
        std::vector<benchmark::idl::OwnerV2>&& _vec_own_v2)
{
    m_vec_own_v2 = std::move(_vec_own_v2);
}

/*!
 * @brief This function returns a constant reference to member vec_own_v2
 * @return Constant reference to member vec_own_v2
 */
const std::vector<benchmark::idl::OwnerV2>& benchmark::idl::Pet::vec_own_v2() const
{
    return m_vec_own_v2;
}

/*!
 * @brief This function returns a reference to member vec_own_v2
 * @return Reference to member vec_own_v2
 */
std::vector<benchmark::idl::OwnerV2>& benchmark::idl::Pet::vec_own_v2()
{
    return m_vec_own_v2;
}
/*!
 * @brief This function copies the value in member own_v3
 * @param _own_v3 New value to be copied in member own_v3
 */
void benchmark::idl::Pet::own_v3(
        const benchmark::idl::OwnerV3& _own_v3)
{
    m_own_v3 = _own_v3;
}

/*!
 * @brief This function moves the value in member own_v3
 * @param _own_v3 New value to be moved in member own_v3
 */
void benchmark::idl::Pet::own_v3(
        benchmark::idl::OwnerV3&& _own_v3)
{
    m_own_v3 = std::move(_own_v3);
}

/*!
 * @brief This function returns a constant reference to member own_v3
 * @return Constant reference to member own_v3
 */
const benchmark::idl::OwnerV3& benchmark::idl::Pet::own_v3() const
{
    return m_own_v3;
}

/*!
 * @brief This function returns a reference to member own_v3
 * @return Reference to member own_v3
 */
benchmark::idl::OwnerV3& benchmark::idl::Pet::own_v3()
{
    return m_own_v3;
}
/*!
 * @brief This function copies the value in member arr_own_v3
 * @param _arr_own_v3 New value to be copied in member arr_own_v3
 */
void benchmark::idl::Pet::arr_own_v3(
        const std::array<benchmark::idl::OwnerV3, 10000>& _arr_own_v3)
{
    m_arr_own_v3 = _arr_own_v3;
}

/*!
 * @brief This function moves the value in member arr_own_v3
 * @param _arr_own_v3 New value to be moved in member arr_own_v3
 */
void benchmark::idl::Pet::arr_own_v3(
        std::array<benchmark::idl::OwnerV3, 10000>&& _arr_own_v3)
{
    m_arr_own_v3 = std::move(_arr_own_v3);
}

/*!
 * @brief This function returns a constant reference to member arr_own_v3
 * @return Constant reference to member arr_own_v3
 */
const std::array<benchmark::idl::OwnerV3, 10000>& benchmark::idl::Pet::arr_own_v3() const
{
    return m_arr_own_v3;
}

/*!
 * @brief This function returns a reference to member arr_own_v3
 * @return Reference to member arr_own_v3
 */
std::array<benchmark::idl::OwnerV3, 10000>& benchmark::idl::Pet::arr_own_v3()
{
    return m_arr_own_v3;
}
/*!
 * @brief This function copies the value in member vec_own_v3
 * @param _vec_own_v3 New value to be copied in member vec_own_v3
 */
void benchmark::idl::Pet::vec_own_v3(
        const std::vector<benchmark::idl::OwnerV3>& _vec_own_v3)
{
    m_vec_own_v3 = _vec_own_v3;
}

/*!
 * @brief This function moves the value in member vec_own_v3
 * @param _vec_own_v3 New value to be moved in member vec_own_v3
 */
void benchmark::idl::Pet::vec_own_v3(
        std::vector<benchmark::idl::OwnerV3>&& _vec_own_v3)
{
    m_vec_own_v3 = std::move(_vec_own_v3);
}

/*!
 * @brief This function returns a constant reference to member vec_own_v3
 * @return Constant reference to member vec_own_v3
 */
const std::vector<benchmark::idl::OwnerV3>& benchmark::idl::Pet::vec_own_v3() const
{
    return m_vec_own_v3;
}

/*!
 * @brief This function returns a reference to member vec_own_v3
 * @return Reference to member vec_own_v3
 */
std::vector<benchmark::idl::OwnerV3>& benchmark::idl::Pet::vec_own_v3()
{
    return m_vec_own_v3;
}
/*!
 * @brief This function copies the value in member own_v4
 * @param _own_v4 New value to be copied in member own_v4
 */
void benchmark::idl::Pet::own_v4(
        const benchmark::idl::OwnerV4& _own_v4)
{
    m_own_v4 = _own_v4;
}

/*!
 * @brief This function moves the value in member own_v4
 * @param _own_v4 New value to be moved in member own_v4
 */
void benchmark::idl::Pet::own_v4(
        benchmark::idl::OwnerV4&& _own_v4)
{
    m_own_v4 = std::move(_own_v4);
}

/*!
 * @brief This function returns a constant reference to member own_v4
 * @return Constant reference to member own_v4
 */
const benchmark::idl::OwnerV4& benchmark::idl::Pet::own_v4() const
{
    return m_own_v4;
}

/*!
 * @brief This function returns a reference to member own_v4
 * @return Reference to member own_v4
 */
benchmark::idl::OwnerV4& benchmark::idl::Pet::own_v4()
{
    return m_own_v4;
}
/*!
 * @brief This function copies the value in member arr_own_v4
 * @param _arr_own_v4 New value to be copied in member arr_own_v4
 */
void benchmark::idl::Pet::arr_own_v4(
        const std::array<benchmark::idl::OwnerV4, 10000>& _arr_own_v4)
{
    m_arr_own_v4 = _arr_own_v4;
}

/*!
 * @brief This function moves the value in member arr_own_v4
 * @param _arr_own_v4 New value to be moved in member arr_own_v4
 */
void benchmark::idl::Pet::arr_own_v4(
        std::array<benchmark::idl::OwnerV4, 10000>&& _arr_own_v4)
{
    m_arr_own_v4 = std::move(_arr_own_v4);
}

/*!
 * @brief This function returns a constant reference to member arr_own_v4
 * @return Constant reference to member arr_own_v4
 */
const std::array<benchmark::idl::OwnerV4, 10000>& benchmark::idl::Pet::arr_own_v4() const
{
    return m_arr_own_v4;
}

/*!
 * @brief This function returns a reference to member arr_own_v4
 * @return Reference to member arr_own_v4
 */
std::array<benchmark::idl::OwnerV4, 10000>& benchmark::idl::Pet::arr_own_v4()
{
    return m_arr_own_v4;
}
/*!
 * @brief This function copies the value in member vec_own_v4
 * @param _vec_own_v4 New value to be copied in member vec_own_v4
 */
void benchmark::idl::Pet::vec_own_v4(
        const std::vector<benchmark::idl::OwnerV4>& _vec_own_v4)
{
    m_vec_own_v4 = _vec_own_v4;
}

/*!
 * @brief This function moves the value in member vec_own_v4
 * @param _vec_own_v4 New value to be moved in member vec_own_v4
 */
void benchmark::idl::Pet::vec_own_v4(
        std::vector<benchmark::idl::OwnerV4>&& _vec_own_v4)
{
    m_vec_own_v4 = std::move(_vec_own_v4);
}

/*!
 * @brief This function returns a constant reference to member vec_own_v4
 * @return Constant reference to member vec_own_v4
 */
const std::vector<benchmark::idl::OwnerV4>& benchmark::idl::Pet::vec_own_v4() const
{
    return m_vec_own_v4;
}

/*!
 * @brief This function returns a reference to member vec_own_v4
 * @return Reference to member vec_own_v4
 */
std::vector<benchmark::idl::OwnerV4>& benchmark::idl::Pet::vec_own_v4()
{
    return m_vec_own_v4;
}
/*!
 * @brief This function sets a value in member pet_type
 * @param _pet_type New value for member pet_type
 */
void benchmark::idl::Pet::pet_type(
        benchmark::idl::PetType _pet_type)
{
    m_pet_type = _pet_type;
}

/*!
 * @brief This function returns the value of member pet_type
 * @return Value of member pet_type
 */
benchmark::idl::PetType benchmark::idl::Pet::pet_type() const
{
    return m_pet_type;
}

/*!
 * @brief This function returns a reference to member pet_type
 * @return Reference to member pet_type
 */
benchmark::idl::PetType& benchmark::idl::Pet::pet_type()
{
    return m_pet_type;
}

/*!
 * @brief This function copies the value in member arr_pet_type
 * @param _arr_pet_type New value to be copied in member arr_pet_type
 */
void benchmark::idl::Pet::arr_pet_type(
        const std::array<benchmark::idl::PetType, 10000>& _arr_pet_type)
{
    m_arr_pet_type = _arr_pet_type;
}

/*!
 * @brief This function moves the value in member arr_pet_type
 * @param _arr_pet_type New value to be moved in member arr_pet_type
 */
void benchmark::idl::Pet::arr_pet_type(
        std::array<benchmark::idl::PetType, 10000>&& _arr_pet_type)
{
    m_arr_pet_type = std::move(_arr_pet_type);
}

/*!
 * @brief This function returns a constant reference to member arr_pet_type
 * @return Constant reference to member arr_pet_type
 */
const std::array<benchmark::idl::PetType, 10000>& benchmark::idl::Pet::arr_pet_type() const
{
    return m_arr_pet_type;
}

/*!
 * @brief This function returns a reference to member arr_pet_type
 * @return Reference to member arr_pet_type
 */
std::array<benchmark::idl::PetType, 10000>& benchmark::idl::Pet::arr_pet_type()
{
    return m_arr_pet_type;
}
/*!
 * @brief This function copies the value in member vec_pet_type
 * @param _vec_pet_type New value to be copied in member vec_pet_type
 */
void benchmark::idl::Pet::vec_pet_type(
        const std::vector<benchmark::idl::PetType>& _vec_pet_type)
{
    m_vec_pet_type = _vec_pet_type;
}

/*!
 * @brief This function moves the value in member vec_pet_type
 * @param _vec_pet_type New value to be moved in member vec_pet_type
 */
void benchmark::idl::Pet::vec_pet_type(
        std::vector<benchmark::idl::PetType>&& _vec_pet_type)
{
    m_vec_pet_type = std::move(_vec_pet_type);
}

/*!
 * @brief This function returns a constant reference to member vec_pet_type
 * @return Constant reference to member vec_pet_type
 */
const std::vector<benchmark::idl::PetType>& benchmark::idl::Pet::vec_pet_type() const
{
    return m_vec_pet_type;
}

/*!
 * @brief This function returns a reference to member vec_pet_type
 * @return Reference to member vec_pet_type
 */
std::vector<benchmark::idl::PetType>& benchmark::idl::Pet::vec_pet_type()
{
    return m_vec_pet_type;
}
/*!
 * @brief This function copies the value in member arr_u8
 * @param _arr_u8 New value to be copied in member arr_u8
 */
void benchmark::idl::Pet::arr_u8(
        const std::array<uint8_t, 10000>& _arr_u8)
{
    m_arr_u8 = _arr_u8;
}

/*!
 * @brief This function moves the value in member arr_u8
 * @param _arr_u8 New value to be moved in member arr_u8
 */
void benchmark::idl::Pet::arr_u8(
        std::array<uint8_t, 10000>&& _arr_u8)
{
    m_arr_u8 = std::move(_arr_u8);
}

/*!
 * @brief This function returns a constant reference to member arr_u8
 * @return Constant reference to member arr_u8
 */
const std::array<uint8_t, 10000>& benchmark::idl::Pet::arr_u8() const
{
    return m_arr_u8;
}

/*!
 * @brief This function returns a reference to member arr_u8
 * @return Reference to member arr_u8
 */
std::array<uint8_t, 10000>& benchmark::idl::Pet::arr_u8()
{
    return m_arr_u8;
}


size_t benchmark::idl::Pet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return benchmark_idl_Pet_max_key_cdr_typesize;
}

bool benchmark::idl::Pet::isKeyDefined()
{
    return false;
}

void benchmark::idl::Pet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



